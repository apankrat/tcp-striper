

                           Tcp-striper
			   -----------
                        (from "to stripe")



                         --  SUMMARY  --


Have

      +--------+                                    +--------+
      |        |                                    |        |
      | Peer A |  <------[ TCP connection ]------>  | Peer B |
      |        |                                    |        |
      +--------+                                    +--------+

Want

      +--------+        +---+          +---+        +--------+
      |        |        |   |  <---->  |   |        |        |
      | Peer A |  <-->  | P |  <---->  | P |  <-->  | Peer B |
      |        |        |   |  <---->  |   |        |        |
      +--------+        +---+          +---+        +--------+


That is - to splice a pair of intermediate proxies into a TCP
connection and then have them talk via multiple TCP streams in 
parallel.


In particular, if an active stream between the proxies gets
congested, they would switch to another non-congested stream.
This should help proxies push more traffic through if/when
there are per-stream caps on the route between A and B. Like
the ones my cable provider has :)



                         --  STATUS  --

15/09/14

  -- 1 --

  Re-organized the code as follows:

    /core - basic type imports, macros, assert() and logging
    /data - data containers (list and unbalanced map for now)
    /evl  - event loop (select-based for now)
    /io   - IO pipes & Co. - that's where the magic is
    /sys  - the platform glue (socket interface, termio, etc)

  Each of these has the following structure:

    ./inc/libp/        <portable-headers>
    ./inc.$OS/libp/    <os-specific-version-of-the-same>
    ./src/             <portable-sources>
    ./src.$OS          <os-specific-sources>

  Then, setting INCLUDE path to ./inc.linux, ./inc and will
  make the compiler pick an OS-specific version of a header 
  when it encounters 
  
  	#include <libp/foo.h>

  if such version is present. Otherwise it falls back to a 
  generic portable version. See Makefile for details.

  -- 2 --

  The bestest part is in the /io. The io_pipe interface is a
  stateful IO abstraction based on TCP, but also allowing 
  extension of the send/recv behavior. For example, a pipe 
  of certain type can provide datagram framing, another type
  - SSL encryption, third - atomic send() behavior, etc. So
  you could attach these pipes one to another and get a 
  a reliable encrypted datagram-based connection.
  
  Moreover, it becomes possible to write a generalized bridge
  between any two pipes, which reads from one, writes to 
  another, minds the congestion and properly handles passing
  of the FINs between the peers. That's io_bridge.

  This is what tcp-striper does at the moment - it's a simple
  TCP proxy that accepts a connection on 0.0.0.0:55555, opens
  another one to 127.0.0.1:22 and then just bridges them 
  together. In other words, it's a TCP relay.

  The next step would be to add a special pipe type that
  maintains 2+ connections towards the peer and then stripes
  all data passed to it via send() between these connections.
  On the peer's end there'll be a complimentary pipe that
  would reverse the striping, re-assemble the data into a
  single stream and pass it to the app's io_bridge for 
  relaying out.

  Easy-peasy.

28/08/14

  * Initial public offering (via github upload)

27/08/14

  * Simple TCP proxy with tracking of per-leg congestion
    (proxy_types.*)

26/08/14

  * Select-based event loop
    (event_loop/*)

25/08/14

  * Abstracted socket API (glue/*/socket.h)
  * Basic data containers (map is unbalanced!)
  * Basic app scaffolding (asserts, types, macros)
  * Makefile

--------------------------------------------------------------
              Work in progress, a weekend project.
--------------------------------------------------------------

